<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Slot Machine 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: sans-serif; }
        
        #ui-container {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        button {
            pointer-events: auto;
            background: linear-gradient(to bottom, #ff9800, #f57c00);
            color: white;
            border: 2px solid #fff;
            padding: 15px 50px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transition: transform 0.1s;
            text-transform: uppercase;
        }

        button:active { transform: scale(0.95); }
        button:disabled { filter: grayscale(1); cursor: not-allowed; }

        #status {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            z-index: 10;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="status">Cargando modelos grandes...</div>
    <div id="ui-container">
        <button id="btnSpin" disabled>Â¡GIRAR!</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- CONFIGURACIÃ“N ---
        const REEL_COUNT = 3;        
        
        // AJUSTES DE TAMAÃ‘O Y ESPACIO
        // Al hacerlos el doble de grandes, necesitamos mÃ¡s espacio:
        const RADIUS = 4.5;          // Radio del cÃ­rculo (antes 2.8)
        const REEL_GAP = 5.0;        // SeparaciÃ³n entre rodillos (antes 3.0)

        // CONFIGURACIÃ“N INDIVIDUAL DE CADA PERSONAJE
        // AquÃ­ puedes ajustar rotaciÃ³n si salen de espaldas o altura si salen hundidos
        const MODEL_DATA = [
            { 
                url: './noel.glb', 
                scale: 2.0,        // TAMAÃ‘O DOBLE
                rotateY: 0,        // RotaciÃ³n izq/der (Usa Math.PI para 180Âº)
                offsetY: -1.0      // Bajar un poco para centrar en el eje
            },
            { 
                url: './sirena.glb', 
                scale: 2.0,        // TAMAÃ‘O DOBLE
                rotateY: 0, 
                offsetY: -1.0 
            },
            { 
                url: './xic.glb', 
                scale: 2.0,        // TAMAÃ‘O DOBLE
                rotateY: 0, 
                offsetY: -1.0 
            }
        ];

        // Duplicamos la lista para tener 6 sÃ­mbolos en el rodillo:
        // PatrÃ³n: Noel -> Sirena -> Xic -> Noel -> Sirena -> Xic
        const MODEL_CONFIGS = [...MODEL_DATA, ...MODEL_DATA];
        const SYMBOLS_PER_REEL = MODEL_CONFIGS.length;

        // --- VARIABLES GLOBALES ---
        let scene, camera, renderer;
        const reels = []; 
        const loadedTemplates = []; // Guardamos los modelos base aquÃ­
        let isSpinning = false;

        init();

        function init() {
            // 1. ESCENA
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            // Alejamos la cÃ¡mara porque los modelos ahora son gigantes
            camera.position.set(0, 0, 22); 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 2. LUCES
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); 
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 10, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // 3. CARGAR RECURSOS
            loadAssets();

            // Evento BotÃ³n
            document.getElementById('btnSpin').addEventListener('click', startSpin);
        }

        async function loadAssets() {
            const loader = new GLTFLoader();
            let loadedCount = 0;

            // Cargamos SOLO los 3 modelos Ãºnicos
            for (let i = 0; i < MODEL_DATA.length; i++) {
                const config = MODEL_DATA[i];
                
                try {
                    const gltf = await loader.loadAsync(config.url);
                    const model = gltf.scene;

                    // 1. APLICAR ESCALA Y POSICIÃ“N
                    model.scale.set(config.scale, config.scale, config.scale);
                    
                    // 2. WRAPPER (Contenedor para corregir rotaciÃ³n sin romper la mÃ¡quina)
                    const wrapper = new THREE.Group();
                    
                    model.rotation.y = config.rotateY;
                    model.position.y = config.offsetY; // Ajuste vertical individual
                    
                    // Sombras
                    model.traverse(c => { if(c.isMesh) c.castShadow = true; });

                    wrapper.add(model);
                    
                    // Guardamos la plantilla
                    loadedTemplates.push(wrapper);
                    loadedCount++;
                    console.log(`Cargado: ${config.url}`);

                } catch (error) {
                    console.error(`Error cargando ${config.url}:`, error);
                    // Cubo de error
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color:0xff0000}));
                    loadedTemplates.push(mesh);
                    loadedCount++;
                }
            }

            if (loadedCount === MODEL_DATA.length) {
                createMachine();
                document.getElementById('status').innerText = "Â¡Listo para jugar!";
                document.getElementById('btnSpin').disabled = false;
                animate();
            }
        }

        function createMachine() {
            const angleStep = (Math.PI * 2) / SYMBOLS_PER_REEL;

            for (let i = 0; i < REEL_COUNT; i++) {
                const reelGroup = new THREE.Group();
                reelGroup.position.x = (i - 1) * REEL_GAP; 

                for (let j = 0; j < SYMBOLS_PER_REEL; j++) {
                    // Calculamos quÃ© modelo toca (0, 1, 2, 0, 1, 2)
                    const templateIndex = j % MODEL_DATA.length;
                    
                    // CLONAR el modelo base
                    const symbol = loadedTemplates[templateIndex].clone();

                    // MatemÃ¡ticas circulares
                    const theta = j * angleStep;
                    
                    symbol.position.y = RADIUS * Math.cos(theta);
                    symbol.position.z = RADIUS * Math.sin(theta) * -1;

                    // Rotar el contenedor para que siga la curvatura del rodillo
                    symbol.rotation.x = theta;

                    reelGroup.add(symbol);
                }

                scene.add(reelGroup);
                
                reels.push({
                    mesh: reelGroup,
                    speed: 0,
                    targetRotation: 0,
                    resultIndex: 0, // AquÃ­ guardaremos quÃ© sÃ­mbolo saliÃ³
                    isStopping: false
                });
            }
        }

        function startSpin() {
            if (isSpinning) return;
            isSpinning = true;
            document.getElementById('status').innerText = "Girando...";
            document.getElementById('status').style.color = "white";
            document.getElementById('btnSpin').disabled = true;

            // Resetear colores o efectos si quieres
            camera.position.z = 22; 

            reels.forEach((reel, index) => {
                reel.speed = 0.3 + Math.random() * 0.1; 
                reel.isStopping = false;
                
                // Parar secuencialmente
                setTimeout(() => {
                    stopReel(index);
                }, 2000 + (index * 600)); 
            });
        }

        function stopReel(index) {
            const reel = reels[index];
            reel.isStopping = true;
            const angleStep = (Math.PI * 2) / SYMBOLS_PER_REEL;
            
            // Decidir ganador al azar (0 a 5)
            const stopIndex = Math.floor(Math.random() * SYMBOLS_PER_REEL);
            reel.resultIndex = stopIndex;
            
            const currentRotation = reel.mesh.rotation.x;
            // Aseguramos al menos 2 vueltas completas mÃ¡s antes de parar
            const rawTarget = currentRotation + (Math.PI * 4); 
            
            // Calcular Ã¡ngulo exacto
            reel.targetRotation = Math.ceil(rawTarget / angleStep) * angleStep + (angleStep * stopIndex);
        }

        function checkWin() {
            const statusText = document.getElementById('status');
            
            // Convertimos el Ã­ndice del rodillo (0-5) a tipo de personaje (0-2)
            // 0=Noel, 1=Sirena, 2=Xic, 3=Noel, 4=Sirena, 5=Xic
            const r1 = reels[0].resultIndex % 3;
            const r2 = reels[1].resultIndex % 3;
            const r3 = reels[2].resultIndex % 3;

            console.log("Resultados:", r1, r2, r3);

            if (r1 === r2 && r1 === r3) {
                // TRES IGUALES
                statusText.innerText = "ðŸŽ‰ Â¡Â¡PREMIO GORDO!! ðŸŽ‰";
                statusText.style.color = "#FFD700"; // Dorado
                
                // Efecto Zoom
                let zoomIn = true;
                const zoomInterval = setInterval(() => {
                    if(zoomIn) camera.position.z -= 0.1;
                    else camera.position.z += 0.1;
                    if(camera.position.z < 18) zoomIn = false;
                    if(camera.position.z > 22) clearInterval(zoomInterval);
                }, 16);

            } else if (r1 === r2 || r2 === r3 || r1 === r3) {
                // DOS IGUALES
                statusText.innerText = "âœ¨ Â¡Casi! Tienes pareja âœ¨";
                statusText.style.color = "#00ff00"; // Verde
            } else {
                statusText.innerText = "IntÃ©ntalo de nuevo";
                statusText.style.color = "#ffffff";
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            let stoppedCount = 0;

            reels.forEach(reel => {
                if (!reel.isStopping) {
                    reel.mesh.rotation.x += reel.speed;
                } else {
                    // Lerp para frenado suave
                    const delta = (reel.targetRotation - reel.mesh.rotation.x);
                    reel.mesh.rotation.x += delta * 0.05;

                    if (Math.abs(delta) < 0.005) {
                        reel.mesh.rotation.x = reel.targetRotation;
                        stoppedCount++;
                    }
                }
            });

            if (stoppedCount === REEL_COUNT && isSpinning) {
                isSpinning = false;
                document.getElementById('btnSpin').disabled = false;
                checkWin();
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>